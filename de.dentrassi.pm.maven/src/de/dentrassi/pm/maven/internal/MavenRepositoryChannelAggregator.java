/*******************************************************************************
 * Copyright (c) 2015 IBH SYSTEMS GmbH.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBH SYSTEMS GmbH - initial API and implementation
 *     Markus Rathgeb - support multiple POMs per artifact
 *******************************************************************************/
package de.dentrassi.pm.maven.internal;

import static de.dentrassi.pm.common.XmlHelper.addElement;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;

import org.apache.commons.io.FilenameUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import de.dentrassi.pm.VersionInformation;
import de.dentrassi.pm.aspect.aggregate.AggregationContext;
import de.dentrassi.pm.aspect.aggregate.ChannelAggregator;
import de.dentrassi.pm.common.ArtifactInformation;
import de.dentrassi.pm.common.MetaKeys;
import de.dentrassi.pm.common.XmlHelper;
import de.dentrassi.pm.core.CoreService;
import de.dentrassi.pm.maven.ChannelData;
import de.dentrassi.pm.maven.MavenInformation;
import de.dentrassi.pm.system.SystemService;

public class MavenRepositoryChannelAggregator implements ChannelAggregator
{
    private final XmlHelper xml = new XmlHelper ();

    private final CoreService coreService;

    private final SystemService systemService;

    private static final String NL = "\n";

    public MavenRepositoryChannelAggregator ( final CoreService coreService, final SystemService systemService )
    {
        this.coreService = coreService;
        this.systemService = systemService;
    }

    protected String getSitePrefix ()
    {
        final String prefix = this.coreService.getCoreProperty ( "site-prefix", this.systemService.getDefaultSitePrefix () );
        if ( prefix != null )
        {
            return prefix;
        }
        return "http://localhost:8080";
    }

    @Override
    public String getId ()
    {
        return MavenRepositoryAspectFactory.ID;
    }

    @Override
    public Map<String, String> aggregateMetaData ( final AggregationContext context ) throws Exception
    {
        final Map<String, ArtifactInformation> map = makeMap ( context );

        final Map<String, String> result = new HashMap<> ();

        final ChannelData cs = new ChannelData ();

        final Set<String> groupIds = new HashSet<> ();

        for ( final ArtifactInformation art : context.getArtifacts () )
        {
            final Collection<MavenInformation> infos = getInfos ( art, map );

            for ( final MavenInformation info : infos )
            {
                // add
                try
                {
                    cs.add ( info, art );
                    groupIds.add ( info.getGroupId () );
                }
                catch ( final IllegalStateException ex )
                {
                    // Cannot add the same information made name (info.makeName()) multiple times.
                    // First-come, first-served.
                }
            }
        }

        String json = cs.toJson ();
        result.put ( "channel", json );

        json = cs.toString ();
        context.createCacheEntry ( "channel", "channel.json", "application/json", new ByteArrayInputStream ( json.getBytes ( StandardCharsets.UTF_8 ) ) );
        context.createCacheEntry ( "repo-metadata", "repository-metadata.xml", "text/xml", ( stream ) -> {
            try
            {
                this.xml.write ( makeRepoMetaData ( context ), stream );
            }
            catch ( final Exception e )
            {
                throw new IOException ( e );
            }
        } );
        context.createCacheEntry ( "prefixes", "prefixes.txt", "text/plain", ( stream ) -> makePrefixes ( stream, groupIds ) );

        return result;
    }

    private void makePrefixes ( final OutputStream stream, final Set<String> groupIds ) throws IOException
    {
        final OutputStreamWriter writer = new OutputStreamWriter ( stream, StandardCharsets.UTF_8 );

        writer.write ( "## repository-prefixes/2.0" + NL );
        writer.write ( "#" + NL );
        writer.write ( "# Generated by Package Drone " + VersionInformation.VERSION + NL );

        final String[] groups = groupIds.toArray ( new String[groupIds.size ()] );
        Arrays.sort ( groups );
        for ( final String groupId : groups )
        {
            writer.write ( "/" );
            writer.write ( groupId.replace ( ".", "/" ) );
            writer.write ( NL );
        }

        writer.close ();
    }

    /**
     * Create the repository meta data file, for scraping
     *
     * @param context
     * @return the document
     */
    private Document makeRepoMetaData ( final AggregationContext context )
    {
        final Document doc = this.xml.create ();

        // create document

        final Element root = doc.createElement ( "repository-metadata" );
        doc.appendChild ( root );

        addElement ( root, "version", "1.0.0" );
        addElement ( root, "id", context.getChannelId () );
        addElement ( root, "name", context.getChannelNameOrId () );
        addElement ( root, "layout", "maven2" );
        addElement ( root, "policy", "mixed" );
        addElement ( root, "url", makeUrl ( context.getChannelId () ) );

        return doc;
    }

    private String makeUrl ( final String channelId )
    {
        return String.format ( "%s/maven/%s", getSitePrefix (), channelId );
    }

    private Map<String, ArtifactInformation> makeMap ( final AggregationContext context )
    {
        final Map<String, ArtifactInformation> result = new HashMap<> ();

        for ( final ArtifactInformation art : context.getArtifacts () )
        {
            result.put ( art.getId (), art );
        }

        return result;
    }

    private Collection<MavenInformation> getInfos ( final ArtifactInformation art, final Map<String, ArtifactInformation> map )
    {
        final Collection<MavenInformation> infos = new LinkedList<> ();

        /*
         * Try to use the info of the artifact them-self.
         */

        try
        {
            final MavenInformation info = new MavenInformation ();
            MetaKeys.bind ( info, art.getMetaData () );
            if ( info.getGroupId () != null && info.getArtifactId () != null && info.getVersion () != null )
            {
                // found direct meta data
                infos.add ( info );
            }
        }
        catch ( final Exception e )
        {
        }

        /*
         * Try to add all child POM files.
         */

        final Collection<ArtifactInformation> pomArts = findChildPoms ( art, map );
        for ( final ArtifactInformation pomArt : pomArts )
        {
            try
            {
                final MavenInformation info = new MavenInformation ();
                MetaKeys.bind ( info, pomArt.getMetaData () );
                if ( info.getGroupId () != null && info.getArtifactId () != null && info.getVersion () != null )
                {
                    // found pom meta data
                    final String ext = FilenameUtils.getExtension ( art.getName () );
                    if ( ext != null )
                    {
                        info.setExtension ( ext );
                        infos.add ( info );
                    }
                }
            }
            catch ( final Exception e )
            {
            }
        }

        return infos;
    }

    /**
     * Return a set with all child POMs
     *
     * @param art
     * @param map
     * @return a set with all child POMs, an empty set if no child POM is found.
     */
    private Collection<ArtifactInformation> findChildPoms ( final ArtifactInformation art, final Map<String, ArtifactInformation> map )
    {
        final Collection<ArtifactInformation> poms = new LinkedList<> ();

        if ( isPomFileName ( art.getName () ) )
        {
            poms.add ( art );
        }
        else
        {
            for ( final ArtifactInformation child : map.values () )
            {
                final String childName = child.getName ();

                if ( isPomFileName ( childName ) )
                {
                    poms.add ( child );
                }
            }
        }

        return poms;
    }

    private static boolean isPomFileName ( final String fileName )
    {
        return "pom.xml".equals ( fileName ) || "pom".equals ( FilenameUtils.getExtension ( fileName ) );
    }

}
